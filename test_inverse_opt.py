'''
Created on Jun 6, 2014

@author: jeromethai
'''

import numpy as np
import ue_solver as ue
import inverse_opt as invopt
from test_graph import los_angeles
import matplotlib.pyplot as plt
from cvxopt import matrix
import draw_graph as d
from numpy.random import normal

od_flows1 = [3.0, 3.0, 1.0, 1.0];
od_flows2 = [1.0, 1.0, 1.0, 4.0];
theta_true = matrix([0.0, 0.0, 0.0, 1.0, 0.0, 0.0])
theta_true /= np.sum(theta_true)

theta_true *= 0.15
degree = len(theta_true)
    
    
def display_results(true_linkflows, est_linkflows, theta_true, best_theta):
    """Display results
    
    Parameters
    ----------
    true_linkflows: list of true linkflows
    est_linkflows: list of estimated linkflows
    theta_true: true parameters
    best_theta: best parameters
    """
    error = np.linalg.norm(matrix(true_linkflows) - matrix(est_linkflows))
    xdata = np.linspace(0.0, 2.5, num=100)
    vals = [1+(best_theta.T * matrix(np.power(x,range(1,degree+1))))[0] for x in xdata]
    true_vals = [1+(theta_true.T * matrix(np.power(x,range(1,degree+1))))[0] for x in xdata]
    plt.plot(xdata, vals, 'r', label='estimate')
    plt.plot( xdata, true_vals, 'b', label='true')
    plt.xlabel('Link flow')
    plt.ylabel('Delay')
    plt.title(r'Estimated delay function. l2-norm error: {:.3f}'.format(error))
    plt.legend()
    plt.show()
    
    
def get_graphs_linkflows(theta, noisy=False):
    """Given parameters theta, get L.A. graphs and associated UE linkflows for polynomial delay functions
    """
    g1, g2, g3, g4 = los_angeles(theta, 'Polynomial', noisy)
    l1, l2, l3, l4 = ue.solver(g1, update=False), ue.solver(g2, update=False), ue.solver(g3, update=False), ue.solver(g4, update=False)
    return g1, g2, g3, g4, l1, l2, l3, l4
    
    
def test1():
    """3-fold test to find smooth that minimizes the distance between x_true (exact)
    and x generated by each candidate function with TOTAL observation
    results of the 3-fold: best smooth = [30, 30, 60, 60, 3000, 3000]
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    min_error = np.inf
    for i in [10.0, 30.0, 60.0]:
        for j in [30.0, 60.0, 100.0]:
            for k in [1000.0, 3000.0, 6000.0]:
                smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                theta = invopt.solver([g1, g2, g3, g4], [l1, l2, l3, l4], degree, smooth)
                g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta)
                error = np.linalg.norm(matrix([l1,l2,l3,l4])-matrix([x1,x2,x3,x4]))
                if error < min_error:
                    best_smooth, min_error, best_theta, y1, y2, y3, y4 = (i,j,k), error, theta, x1, x2, x3, x4
    print best_smooth, min_error
    display_results([l1, l2, l3, l4], [y1, y2, y3, y4], theta_true, best_theta)
    

def test2():
    """3-fold test to find the best smooth using cross validation
    average over the three results with TOTAL observation
    results of the 3-fold best smooth = smooth = [55, 55, 60, 60, 3250, 3250]
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    gs, ls = [g1,g2,g3,g4], [l1,l2,l3,l4]
    best_smooth = [0.0]*4
    
    for index in range(4):
        min_error = np.inf
        for i in [10.0, 30.0, 60.0, 100.0]:
            for j in [30.0, 60.0, 100.0]:
                for k in [600.0, 1000.0, 3000.0, 6000.0]:
                    smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                    theta = invopt.solver(gs[:index]+gs[index+1:], ls[:index]+ls[index+1:], degree, smooth)
                    l = get_graphs_linkflows(theta)[4+index]
                    error = np.linalg.norm(ls[index]-l)
                    if error < min_error: best_smooth[index], min_error = (i,j,k), error    
    print best_smooth

    
def test3(indlinks_obs, max_iter, alt=False):
    """3-fold test to find smooth that minimizes the distance between x^obs_true EXACT
    and x^obs generated by each candidate function with PARTIAL observation
    results for 3-fold with alt=False, obs = [(17,24),(24,40),(14,21),(16,23)]: best smooth = [30, 30, 100, 100, 1000, 1000]
    results for 3-fold with alt=True, obs = [(17,24),(24,40),(14,21),(16,23)]: best smooth = [60, 60, 60, 60, 6000, 6000]
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    obs = [g1.indlinks[id] for id in indlinks_obs]
    min_error = np.inf
    for i in [30.0, 60.0, 100.0]:
        for j in [30.0, 60.0, 100.0]:
            for k in [1000.0, 3000.0, 6000.0]:
                smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                #theta = invopt.solver_mis([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], 
                #                  indlinks_obs, degree, smooth, 1000.0, max_iter, alt=alt)
                theta = invopt.direct_solver([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], indlinks_obs, degree, smooth, 1000.0)
                g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta)
                e = np.linalg.norm(matrix([l1[obs],l2[obs],l3[obs],l4[obs]])-matrix([x1[obs],x2[obs],x3[obs],x4[obs]]))
                if e < min_error:
                    best_smooth, min_error, best_theta = (i,j,k), e, theta
                    y1, y2, y3, y4 = x1, x2, x3, x4        
    print best_smooth, min_error
    display_results([l1, l2, l3, l4], [y1, y2, y3, y4], theta_true, best_theta)
    
    
def test4(indlinks_obs, max_iter, alt=False):
    """3-fold test to find smooth that minimizes the distance between x^obs_true
    and x^obs generated by each candidate function in NOISY case with PARTIAL observation
    results for 3-fold with alt=False, obs = [(17,24),(24,40),(14,21),(16,23)]: best smooth = [30, 30, 600, 600, 600, 600]
    results for 3-fold with alt=True, obs = [(17,24),(24,40),(14,21),(16,23)]: best smooth = [100, 100, 100, 100, 1000, 1000]
    """
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    obs = [g1.indlinks[id] for id in indlinks_obs]
    z1, z2, z3, z4 = l1, l2, l3, l4
    np.random.seed(21)
    l1, l2, l3, l4 = matrix(normal(l1, l1/30.0)), matrix(normal(l2, l2/30.0)), matrix(normal(l3, l3/30.0)), matrix(normal(l4, l4/30.0))
    g1, g2, g3, g4 = los_angeles(theta_true, 'Polynomial', True)
    min_error = np.inf
    for i in [100.0]:
        for j in [100.0]:
            for k in [1000.0]:
                smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                theta = invopt.solver_mis([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], 
                                  indlinks_obs, degree, smooth, 1000.0, max_iter, alt=alt)
                g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta, True)
                e = np.linalg.norm(matrix([l1[obs],l2[obs],l3[obs],l4[obs]])-matrix([x1[obs],x2[obs],x3[obs],x4[obs]]))
                if e < min_error:
                    best_smooth, min_error, best_theta = (i,j,k), e, theta
                    y1, y2, y3, y4 = x1, x2, x3, x4         
    print best_smooth, min_error
    l1, l2, l3, l4 = z1, z2, z3, z4
    display_results([l1, l2, l3, l4], [y1, y2, y3, y4], theta_true, best_theta)
    
    
def test5(max_iter, alt=False, noisy=False):
    """Cross validation to find a sensor that has been attacked
    results when obs = [(17,24),(24,40),(14,21),(16,23)] and (24,40) has been attacked
    """
    indlinks_obs = [(17,24,1), (24,40,1), (14,21,1), (16,23,1)]
    g1, g2, g3, g4, l1, l2, l3, l4 = get_graphs_linkflows(theta_true)
    if noisy:
        g1, g2, g3, g4 = los_angeles(theta_true, 'Polynomial', True)
        l1, l2, l3, l4 = matrix(normal(l1, l1/30.0)), matrix(normal(l2, l2/30.0)), matrix(normal(l3, l3/30.0)), matrix(normal(l4, l4/30.0))
    faulty_id = g1.indlinks[(24,40,1)]
    l1[faulty_id], l2[faulty_id], l3[faulty_id], l4[faulty_id] = 0.7*l1[faulty_id], 0.7*l2[faulty_id], 0.7*l3[faulty_id], 0.7*l4[faulty_id]
    min_error = []
    for k in range(4):
        indlinks = list(indlinks_obs)
        del indlinks[k]
        obs = [g1.indlinks[id] for id in indlinks]
        min_e = np.inf
        for i in [30.0, 60.0, 100.0]:
            for j in [30.0, 60.0, 100.0]:
                for k in [3000.0, 6000.0, 10000.0]:
                    smooth = np.hstack((i*np.ones(degree/3), j*np.ones(degree/3), k*np.ones(degree/3)))
                    theta = invopt.solver_mis([g1, g2, g3, g4], [l1[obs], l2[obs], l3[obs], l4[obs]], 
                                  indlinks, degree, smooth, 1000.0, max_iter, alt=alt)
                    g1, g2, g3, g4, x1, x2, x3, x4 = get_graphs_linkflows(theta, noisy)
                    e = np.linalg.norm(matrix([l1[obs],l2[obs],l3[obs],l4[obs]])-matrix([x1[obs],x2[obs],x3[obs],x4[obs]]))
                    if e < min_e: min_e = e
        min_error.append(min_e)
    print min_error
    

def main():
    
    indlinks_obs = [(17,24,1), (24,40,1), (14,21,1), (16,23,1)]
    #indlinks_obs = graph.indlinks.keys()
    #indlinks_obs = []
    #indlinks_obs = [(10,9,1), (19,18,1), (4,5,1), (29,21,1)]
    
    #test1()
    #test2()
    test3(indlinks_obs, 10, True)
    #test4(indlinks_obs, 10, True)
    #test5(10, True, True)
    
if __name__ == '__main__':
    main()